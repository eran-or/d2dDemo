import { useState, useEffect, MouseEvent, useRef } from "react";
import { draw } from "./drawingUtils";
import { Point, Shape } from "./types";
import { getCanvasMouseCoords, findIntersectingShape } from "./drawingUtils";
import { isInsideShape, isPathClosed } from "./pathUtils";

export const useShapeCreation = (
  canvasRef: React.RefObject<HTMLCanvasElement>,
  image: HTMLImageElement | null,
) => {
  const snapDistance = 10;
  const [isDrawing, setIsDrawing] = useState(false);
  const [shapePath, setShapePath] = useState<Point[]>([]);
  const [isPathComplete, setIsPathComplete] = useState(false);
  const [shapes, setShapes] = useState<Array<Shape>>([]);
  let isDraggingRef = useRef(false);
  let selectedShapeIndexRef = useRef<number | undefined>();
  
  const undoLastShape = () => {
    setShapes((prevShapes) => {
      const shapesCopy = [...prevShapes];
      shapesCopy.pop();
      return shapesCopy;
    });
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (!canvasRef.current || !isDrawing || isPathComplete) return;
    const point = getCanvasMouseCoords(e, canvasRef);
    if (point) {
      setShapePath((prevShapePath) => [...prevShapePath, point]);
    }
    // if (isDraggingRef.current && selectedShapeIndexRef.current) {
      // redraw the canvas with the updated shape positions
      // draw(canvasRef, image, shapes, shapePath, isPathComplete);
    // }
  };

  const handleMouseDown = (e: MouseEvent) => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext("2d");
    if (!ctx) return;
    const point = getCanvasMouseCoords(e, canvasRef);
    if (!point) return;
    const clickedShapeIndex = findIntersectingShape(point, shapes);
    console.log(clickedShapeIndex);
    
    if (clickedShapeIndex !== -1) {
      // Handle shape dragging or other actions for the clicked shape
      for (let i = 0; i < shapes.length; i++) {
        if (isInsideShape(point, shapes[i])) {
          const shape: Shape = shapes[i];
          selectedShapeIndexRef.current = i;
          let leftmost = shape.path[0].x;
          let rightmost = shape.path[0].x;
          let topmost = shape.path[0].y;
          let bottommost = shape.path[0].y;
          for (let j = 1; j < shape.path.length; j++) {
            if (shape.path[j].x < leftmost) {
              leftmost = shape.path[j].x;
            }
            if (shape.path[j].x > rightmost) {
              rightmost = shape.path[j].x;
            }
            if (shape.path[j].y < topmost) {
              topmost = shape.path[j].y;
            }
            if (shape.path[j].y > bottommost) {
              bottommost = shape.path[j].y;
            }
          }

            // create an SVG element with a path element inside it
            let svg = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "svg"
            );
            svg.setAttribute("width", String(rightmost - leftmost));
            svg.setAttribute("height", String(bottommost - topmost));
            let path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            let d =
              "M" +
              (shape.path[0].x - leftmost) +
              "," +
              (shape.path[0].y - topmost);
            for (let j = 1; j < shape.path.length; j++) {
              d +=
                " L" +
                (shape.path[j].x - leftmost) +
                "," +
                (shape.path[j].y - topmost);
            }
            d += " Z";

            path.setAttribute("d", d);
            path.style.fill = "url(#clip-image)";
            svg.appendChild(path);
            let div = document.createElement("div");
            div.appendChild(svg);
            div.draggable = true;
            div.style.position = "absolute";
            div.style.left = (canvasRef.current.offsetLeft + leftmost) + "px";
            div.style.top = (canvasRef.current.offsetTop + topmost) + "px";
            document.body.appendChild(div);

            /** TODO:
             * Create a div, position it on this location and fill it with the shape
             * The div should be dragable
             * Fill the position of the shape with gray
             * When Drop draw the shape on the dropable div
             **/

            // onShapeDragStart(i, { x: leftmost, y: topmost });
           
        } else {
        }
      }

      return; // Prevent any further drawing actions
    }

    if (!isDrawing) {
      setIsDrawing(true);
      if (!isPathComplete) {
        // If the previous path is not complete, add the new point to the current path
        setShapePath((prevShapePath) => [...prevShapePath, point]);
      } else {
        // If the previous path is complete, start a new path
        setShapePath([point]);
        setIsPathComplete(false);
      }
    } else {
      setShapePath((prevShapePath) => [...prevShapePath, point]);
      if (shapePath.length > 2) {
        const isClosed = isPathClosed([...shapePath, point]);
        if (isClosed) {
          setIsPathComplete(true);
          const newShape: Shape = {
            path: [...shapePath, point],
            backgroundData: ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height),
          };
          setShapes((prevShapes) => [...prevShapes, newShape]);
          setShapePath([]);
        }
      }
    }
  };

  const handleMouseUp = (e: MouseEvent) => {
    
  };

  const snapToVertex = (x: number, y: number) => {
    if (shapePath.length === 0) return false;

    const firstPoint = shapePath[0];
    const dx = Math.abs(x - firstPoint.x);
    const dy = Math.abs(y - firstPoint.y);

    return dx <= snapDistance && dy <= snapDistance;
  };
  useEffect(() => {
    draw(canvasRef, image, shapes, shapePath, isPathComplete);
  }, [canvasRef, image, shapes, shapePath, isPathComplete]);

  return {
    handleMouseDown,
    handleMouseUp,
    handleMouseMove,
    undoLastShape,

    shapes,
  };
};
